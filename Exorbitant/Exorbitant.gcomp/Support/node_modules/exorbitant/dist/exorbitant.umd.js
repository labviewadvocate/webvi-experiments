(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.exorbitantHelpers = {}));
}(this, (function (exports) { 'use strict';

  var exorbitant = (function() {
    var _scriptDir = (typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('exorbitant.umd.js', document.baseURI).href));
    
    return (
  function(exorbitant) {
    exorbitant = exorbitant || {};

  var Module = typeof exorbitant !== "undefined" ? exorbitant : {};

  var readyPromiseResolve, readyPromiseReject;

  Module["ready"] = new Promise(function(resolve, reject) {
   readyPromiseResolve = resolve;
   readyPromiseReject = reject;
  });

  Module.exorbitantFlush = flush_NO_FILESYSTEM;

  var moduleOverrides = {};

  var key;

  for (key in Module) {
   if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
   }
  }

  var arguments_ = [];

  var thisProgram = "./this.program";

  var quit_ = function(status, toThrow) {
   throw toThrow;
  };

  var ENVIRONMENT_IS_WEB = false;

  var ENVIRONMENT_IS_WORKER = false;

  var ENVIRONMENT_IS_NODE = false;

  var ENVIRONMENT_IS_SHELL = false;

  ENVIRONMENT_IS_WEB = typeof window === "object";

  ENVIRONMENT_IS_WORKER = typeof importScripts === "function";

  ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";

  ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

  var scriptDirectory = "";

  function locateFile(path) {
   if (Module["locateFile"]) {
    return Module["locateFile"](path, scriptDirectory);
   }
   return scriptDirectory + path;
  }

  var read_, readBinary;

  var nodeFS;

  var nodePath;

  if (ENVIRONMENT_IS_NODE) {
   if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = require("path").dirname(scriptDirectory) + "/";
   } else {
    scriptDirectory = __dirname + "/";
   }
   read_ = function shell_read(filename, binary) {
    if (!nodeFS) nodeFS = require("fs");
    if (!nodePath) nodePath = require("path");
    filename = nodePath["normalize"](filename);
    return nodeFS["readFileSync"](filename, binary ? null : "utf8");
   };
   readBinary = function readBinary(filename) {
    var ret = read_(filename, true);
    if (!ret.buffer) {
     ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
   };
   if (process["argv"].length > 1) {
    thisProgram = process["argv"][1].replace(/\\/g, "/");
   }
   arguments_ = process["argv"].slice(2);
   process["on"]("uncaughtException", function(ex) {
    if (!(ex instanceof ExitStatus)) {
     throw ex;
    }
   });
   process["on"]("unhandledRejection", abort);
   quit_ = function(status) {
    process["exit"](status);
   };
   Module["inspect"] = function() {
    return "[Emscripten Module object]";
   };
  } else if (ENVIRONMENT_IS_SHELL) {
   if (typeof read != "undefined") {
    read_ = function shell_read(f) {
     return read(f);
    };
   }
   readBinary = function readBinary(f) {
    var data;
    if (typeof readbuffer === "function") {
     return new Uint8Array(readbuffer(f));
    }
    data = read(f, "binary");
    assert(typeof data === "object");
    return data;
   };
   if (typeof scriptArgs != "undefined") {
    arguments_ = scriptArgs;
   } else if (typeof arguments != "undefined") {
    arguments_ = arguments;
   }
   if (typeof quit === "function") {
    quit_ = function(status) {
     quit(status);
    };
   }
   if (typeof print !== "undefined") {
    if (typeof console === "undefined") console = {};
    console.log = print;
    console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
   }
  } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
   if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = self.location.href;
   } else if (document.currentScript) {
    scriptDirectory = document.currentScript.src;
   }
   if (_scriptDir) {
    scriptDirectory = _scriptDir;
   }
   if (scriptDirectory.indexOf("blob:") !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
   } else {
    scriptDirectory = "";
   }
   {
    read_ = function shell_read(url) {
     var xhr = new XMLHttpRequest();
     xhr.open("GET", url, false);
     xhr.send(null);
     return xhr.responseText;
    };
    if (ENVIRONMENT_IS_WORKER) {
     readBinary = function readBinary(url) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", url, false);
      xhr.responseType = "arraybuffer";
      xhr.send(null);
      return new Uint8Array(xhr.response);
     };
    }
   }
  } else ;

  var out = Module["print"] || console.log.bind(console);

  var err = Module["printErr"] || console.warn.bind(console);

  for (key in moduleOverrides) {
   if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
   }
  }

  moduleOverrides = null;

  if (Module["arguments"]) arguments_ = Module["arguments"];

  if (Module["thisProgram"]) thisProgram = Module["thisProgram"];

  if (Module["quit"]) quit_ = Module["quit"];

  var wasmBinary;

  if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];

  var noExitRuntime;

  if (Module["noExitRuntime"]) noExitRuntime = Module["noExitRuntime"];

  if (typeof WebAssembly !== "object") {
   abort("no native wasm support detected");
  }

  var wasmMemory;

  var wasmTable;

  var ABORT = false;

  function assert(condition, text) {
   if (!condition) {
    abort("Assertion failed: " + text);
   }
  }

  var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;

  function UTF8ArrayToString(heap, idx, maxBytesToRead) {
   var endIdx = idx + maxBytesToRead;
   var endPtr = idx;
   while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;
   if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(heap.subarray(idx, endPtr));
   } else {
    var str = "";
    while (idx < endPtr) {
     var u0 = heap[idx++];
     if (!(u0 & 128)) {
      str += String.fromCharCode(u0);
      continue;
     }
     var u1 = heap[idx++] & 63;
     if ((u0 & 224) == 192) {
      str += String.fromCharCode((u0 & 31) << 6 | u1);
      continue;
     }
     var u2 = heap[idx++] & 63;
     if ((u0 & 240) == 224) {
      u0 = (u0 & 15) << 12 | u1 << 6 | u2;
     } else {
      u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
     }
     if (u0 < 65536) {
      str += String.fromCharCode(u0);
     } else {
      var ch = u0 - 65536;
      str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
     }
    }
   }
   return str;
  }

  function UTF8ToString(ptr, maxBytesToRead) {
   return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  }

  function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
   if (!(maxBytesToWrite > 0)) return 0;
   var startIdx = outIdx;
   var endIdx = outIdx + maxBytesToWrite - 1;
   for (var i = 0; i < str.length; ++i) {
    var u = str.charCodeAt(i);
    if (u >= 55296 && u <= 57343) {
     var u1 = str.charCodeAt(++i);
     u = 65536 + ((u & 1023) << 10) | u1 & 1023;
    }
    if (u <= 127) {
     if (outIdx >= endIdx) break;
     heap[outIdx++] = u;
    } else if (u <= 2047) {
     if (outIdx + 1 >= endIdx) break;
     heap[outIdx++] = 192 | u >> 6;
     heap[outIdx++] = 128 | u & 63;
    } else if (u <= 65535) {
     if (outIdx + 2 >= endIdx) break;
     heap[outIdx++] = 224 | u >> 12;
     heap[outIdx++] = 128 | u >> 6 & 63;
     heap[outIdx++] = 128 | u & 63;
    } else {
     if (outIdx + 3 >= endIdx) break;
     heap[outIdx++] = 240 | u >> 18;
     heap[outIdx++] = 128 | u >> 12 & 63;
     heap[outIdx++] = 128 | u >> 6 & 63;
     heap[outIdx++] = 128 | u & 63;
    }
   }
   heap[outIdx] = 0;
   return outIdx - startIdx;
  }

  function stringToUTF8(str, outPtr, maxBytesToWrite) {
   return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  }

  function writeAsciiToMemory(str, buffer, dontAddNull) {
   for (var i = 0; i < str.length; ++i) {
    HEAP8[buffer++ >> 0] = str.charCodeAt(i);
   }
   if (!dontAddNull) HEAP8[buffer >> 0] = 0;
  }

  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

  function updateGlobalBufferAndViews(buf) {
   Module["HEAP8"] = HEAP8 = new Int8Array(buf);
   Module["HEAP16"] = HEAP16 = new Int16Array(buf);
   Module["HEAP32"] = HEAP32 = new Int32Array(buf);
   Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
   Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
   Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
   Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
   Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
  }

  var INITIAL_INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;

  var __ATPRERUN__ = [];

  var __ATINIT__ = [];

  var __ATMAIN__ = [];

  var __ATEXIT__ = [];

  var __ATPOSTRUN__ = [];

  function preRun() {
   if (Module["preRun"]) {
    if (typeof Module["preRun"] == "function") Module["preRun"] = [ Module["preRun"] ];
    while (Module["preRun"].length) {
     addOnPreRun(Module["preRun"].shift());
    }
   }
   callRuntimeCallbacks(__ATPRERUN__);
  }

  function initRuntime() {
   callRuntimeCallbacks(__ATINIT__);
  }

  function preMain() {
   callRuntimeCallbacks(__ATMAIN__);
  }

  function exitRuntime() {
   callRuntimeCallbacks(__ATEXIT__);
  }

  function postRun() {
   if (Module["postRun"]) {
    if (typeof Module["postRun"] == "function") Module["postRun"] = [ Module["postRun"] ];
    while (Module["postRun"].length) {
     addOnPostRun(Module["postRun"].shift());
    }
   }
   callRuntimeCallbacks(__ATPOSTRUN__);
  }

  function addOnPreRun(cb) {
   __ATPRERUN__.unshift(cb);
  }

  function addOnPostRun(cb) {
   __ATPOSTRUN__.unshift(cb);
  }

  var runDependencies = 0;

  var dependenciesFulfilled = null;

  function addRunDependency(id) {
   runDependencies++;
   if (Module["monitorRunDependencies"]) {
    Module["monitorRunDependencies"](runDependencies);
   }
  }

  function removeRunDependency(id) {
   runDependencies--;
   if (Module["monitorRunDependencies"]) {
    Module["monitorRunDependencies"](runDependencies);
   }
   if (runDependencies == 0) {
    if (dependenciesFulfilled) {
     var callback = dependenciesFulfilled;
     dependenciesFulfilled = null;
     callback();
    }
   }
  }

  Module["preloadedImages"] = {};

  Module["preloadedAudios"] = {};

  function abort(what) {
   if (Module["onAbort"]) {
    Module["onAbort"](what);
   }
   what += "";
   err(what);
   ABORT = true;
   what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
   var e = new WebAssembly.RuntimeError(what);
   readyPromiseReject(e);
   throw e;
  }

  function hasPrefix(str, prefix) {
   return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;
  }

  var dataURIPrefix = "data:application/octet-stream;base64,";

  function isDataURI(filename) {
   return hasPrefix(filename, dataURIPrefix);
  }

  var fileURIPrefix = "file://";

  function isFileURI(filename) {
   return hasPrefix(filename, fileURIPrefix);
  }

  var wasmBinaryFile = "exorbitant.wasm";

  if (!isDataURI(wasmBinaryFile)) {
   wasmBinaryFile = locateFile(wasmBinaryFile);
  }

  function getBinary() {
   try {
    if (wasmBinary) {
     return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
     return readBinary(wasmBinaryFile);
    } else {
     throw "both async and sync fetching of the wasm failed";
    }
   } catch (err) {
    abort(err);
   }
  }

  function getBinaryPromise() {
   if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
    return fetch(wasmBinaryFile, {
     credentials: "same-origin"
    }).then(function(response) {
     if (!response["ok"]) {
      throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
     }
     return response["arrayBuffer"]();
    }).catch(function() {
     return getBinary();
    });
   }
   return Promise.resolve().then(getBinary);
  }

  function createWasm() {
   var info = {
    "env": asmLibraryArg,
    "wasi_snapshot_preview1": asmLibraryArg
   };
   function receiveInstance(instance, module) {
    var exports = instance.exports;
    Module["asm"] = exports;
    wasmTable = Module["asm"]["__indirect_function_table"];
    wasmMemory = exports["memory"];
    updateGlobalBufferAndViews(wasmMemory.buffer);
    removeRunDependency();
   }
   addRunDependency();
   function receiveInstantiatedSource(output) {
    receiveInstance(output["instance"]);
   }
   function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
     return WebAssembly.instantiate(binary, info);
    }).then(receiver, function(reason) {
     err("failed to asynchronously prepare wasm: " + reason);
     abort(reason);
    });
   }
   function instantiateAsync() {
    if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
     fetch(wasmBinaryFile, {
      credentials: "same-origin"
     }).then(function(response) {
      var result = WebAssembly.instantiateStreaming(response, info);
      return result.then(receiveInstantiatedSource, function(reason) {
       err("wasm streaming compile failed: " + reason);
       err("falling back to ArrayBuffer instantiation");
       return instantiateArrayBuffer(receiveInstantiatedSource);
      });
     });
    } else {
     return instantiateArrayBuffer(receiveInstantiatedSource);
    }
   }
   if (Module["instantiateWasm"]) {
    try {
     var exports = Module["instantiateWasm"](info, receiveInstance);
     return exports;
    } catch (e) {
     err("Module.instantiateWasm callback failed with error: " + e);
     return false;
    }
   }
   instantiateAsync();
   return {};
  }

  function callRuntimeCallbacks(callbacks) {
   while (callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == "function") {
     callback(Module);
     continue;
    }
    var func = callback.func;
    if (typeof func === "number") {
     if (callback.arg === undefined) {
      wasmTable.get(func)();
     } else {
      wasmTable.get(func)(callback.arg);
     }
    } else {
     func(callback.arg === undefined ? null : callback.arg);
    }
   }
  }

  function _args_get(argv, argv_buf) {
   var bufSize = 0;
   mainArgs.forEach(function(arg, i) {
    var ptr = argv_buf + bufSize;
    HEAP32[argv + i * 4 >> 2] = ptr;
    writeAsciiToMemory(arg, ptr);
    bufSize += arg.length + 1;
   });
   return 0;
  }

  function _args_sizes_get(pargc, pargv_buf_size) {
   HEAP32[pargc >> 2] = mainArgs.length;
   var bufSize = 0;
   mainArgs.forEach(function(arg) {
    bufSize += arg.length + 1;
   });
   HEAP32[pargv_buf_size >> 2] = bufSize;
   return 0;
  }

  var ENV = {};

  function getExecutableName() {
   return thisProgram || "./this.program";
  }

  function getEnvStrings() {
   if (!getEnvStrings.strings) {
    var lang = (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
    var env = {
     "USER": "web_user",
     "LOGNAME": "web_user",
     "PATH": "/",
     "PWD": "/",
     "HOME": "/home/web_user",
     "LANG": lang,
     "_": getExecutableName()
    };
    for (var x in ENV) {
     env[x] = ENV[x];
    }
    var strings = [];
    for (var x in env) {
     strings.push(x + "=" + env[x]);
    }
    getEnvStrings.strings = strings;
   }
   return getEnvStrings.strings;
  }

  function _environ_get(__environ, environ_buf) {
   var bufSize = 0;
   getEnvStrings().forEach(function(string, i) {
    var ptr = environ_buf + bufSize;
    HEAP32[__environ + i * 4 >> 2] = ptr;
    writeAsciiToMemory(string, ptr);
    bufSize += string.length + 1;
   });
   return 0;
  }

  function _environ_sizes_get(penviron_count, penviron_buf_size) {
   var strings = getEnvStrings();
   HEAP32[penviron_count >> 2] = strings.length;
   var bufSize = 0;
   strings.forEach(function(string) {
    bufSize += string.length + 1;
   });
   HEAP32[penviron_buf_size >> 2] = bufSize;
   return 0;
  }

  var SYSCALLS = {
   mappings: {},
   buffers: [ null, [], [] ],
   printChar: function(stream, curr) {
    var buffer = SYSCALLS.buffers[stream];
    if (curr === 0 || curr === 10) {
     (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
     buffer.length = 0;
    } else {
     buffer.push(curr);
    }
   },
   varargs: undefined,
   get: function() {
    SYSCALLS.varargs += 4;
    var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
    return ret;
   },
   getStr: function(ptr) {
    var ret = UTF8ToString(ptr);
    return ret;
   },
   get64: function(low, high) {
    return low;
   }
  };

  function _fd_close(fd) {
   return 0;
  }

  function _fd_read(fd, iov, iovcnt, pnum) {
   var stream = SYSCALLS.getStreamFromFD(fd);
   var num = SYSCALLS.doReadv(stream, iov, iovcnt);
   HEAP32[pnum >> 2] = num;
   return 0;
  }

  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {}

  function flush_NO_FILESYSTEM() {
   if (typeof _fflush !== "undefined") _fflush(0);
   var buffers = SYSCALLS.buffers;
   if (buffers[1].length) SYSCALLS.printChar(1, 10);
   if (buffers[2].length) SYSCALLS.printChar(2, 10);
  }

  function _fd_write(fd, iov, iovcnt, pnum) {
   var num = 0;
   for (var i = 0; i < iovcnt; i++) {
    var ptr = HEAP32[iov + i * 8 >> 2];
    var len = HEAP32[iov + (i * 8 + 4) >> 2];
    for (var j = 0; j < len; j++) {
     SYSCALLS.printChar(fd, HEAPU8[ptr + j]);
    }
    num += len;
   }
   HEAP32[pnum >> 2] = num;
   return 0;
  }

  function _exit(status) {
   exit(status);
  }

  function _proc_exit(code) {
   _exit(code);
  }

  __ATEXIT__.push(flush_NO_FILESYSTEM);

  __ATINIT__.push();

  var asmLibraryArg = {
   "args_get": _args_get,
   "args_sizes_get": _args_sizes_get,
   "environ_get": _environ_get,
   "environ_sizes_get": _environ_sizes_get,
   "fd_close": _fd_close,
   "fd_read": _fd_read,
   "fd_seek": _fd_seek,
   "fd_write": _fd_write,
   "proc_exit": _proc_exit
  };

  var asm = createWasm();

  var _SymbolTable_Create = Module["_SymbolTable_Create"] = function() {
   return (_SymbolTable_Create = Module["_SymbolTable_Create"] = Module["asm"]["SymbolTable_Create"]).apply(null, arguments);
  };

  var _SymbolTable_AddVariable = Module["_SymbolTable_AddVariable"] = function() {
   return (_SymbolTable_AddVariable = Module["_SymbolTable_AddVariable"] = Module["asm"]["SymbolTable_AddVariable"]).apply(null, arguments);
  };

  var _SymbolTable_AddVector = Module["_SymbolTable_AddVector"] = function() {
   return (_SymbolTable_AddVector = Module["_SymbolTable_AddVector"] = Module["asm"]["SymbolTable_AddVector"]).apply(null, arguments);
  };

  var _Expression_Create = Module["_Expression_Create"] = function() {
   return (_Expression_Create = Module["_Expression_Create"] = Module["asm"]["Expression_Create"]).apply(null, arguments);
  };

  var _Expression_RegisterSymbolTable = Module["_Expression_RegisterSymbolTable"] = function() {
   return (_Expression_RegisterSymbolTable = Module["_Expression_RegisterSymbolTable"] = Module["asm"]["Expression_RegisterSymbolTable"]).apply(null, arguments);
  };

  var _Expression_Value = Module["_Expression_Value"] = function() {
   return (_Expression_Value = Module["_Expression_Value"] = Module["asm"]["Expression_Value"]).apply(null, arguments);
  };

  var _Parser_Create = Module["_Parser_Create"] = function() {
   return (_Parser_Create = Module["_Parser_Create"] = Module["asm"]["Parser_Create"]).apply(null, arguments);
  };

  var _Parser_Compile = Module["_Parser_Compile"] = function() {
   return (_Parser_Compile = Module["_Parser_Compile"] = Module["asm"]["Parser_Compile"]).apply(null, arguments);
  };

  var _free = Module["_free"] = function() {
   return (_free = Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
  };

  var __start = Module["__start"] = function() {
   return (__start = Module["__start"] = Module["asm"]["_start"]).apply(null, arguments);
  };

  var stackSave = Module["stackSave"] = function() {
   return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
  };

  var stackRestore = Module["stackRestore"] = function() {
   return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
  };

  var stackAlloc = Module["stackAlloc"] = function() {
   return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
  };

  var _malloc = Module["_malloc"] = function() {
   return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
  };

  Module["UTF8ArrayToString"] = UTF8ArrayToString;

  Module["stringToUTF8"] = stringToUTF8;

  Module["stackSave"] = stackSave;

  Module["stackRestore"] = stackRestore;

  Module["stackAlloc"] = stackAlloc;

  var calledRun;

  function ExitStatus(status) {
   this.name = "ExitStatus";
   this.message = "Program terminated with exit(" + status + ")";
   this.status = status;
  }

  var mainArgs = undefined;

  dependenciesFulfilled = function runCaller() {
   if (!calledRun) run();
   if (!calledRun) dependenciesFulfilled = runCaller;
  };

  function callMain(args) {
   var entryFunction = Module["__start"];
   mainArgs = [ thisProgram ].concat(args);
   try {
    entryFunction();
    var ret = 0;
    exit(ret, true);
   } catch (e) {
    if (e instanceof ExitStatus) {
     return;
    } else if (e == "unwind") {
     noExitRuntime = true;
     return;
    } else {
     var toLog = e;
     if (e && typeof e === "object" && e.stack) {
      toLog = [ e, e.stack ];
     }
     err("exception thrown: " + toLog);
     quit_(1, e);
    }
   } finally {
   }
  }

  function run(args) {
   args = args || arguments_;
   if (runDependencies > 0) {
    return;
   }
   preRun();
   if (runDependencies > 0) return;
   function doRun() {
    if (calledRun) return;
    calledRun = true;
    Module["calledRun"] = true;
    if (ABORT) return;
    initRuntime();
    preMain();
    readyPromiseResolve(Module);
    if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
    if (shouldRunNow) callMain(args);
    postRun();
   }
   if (Module["setStatus"]) {
    Module["setStatus"]("Running...");
    setTimeout(function() {
     setTimeout(function() {
      Module["setStatus"]("");
     }, 1);
     doRun();
    }, 1);
   } else {
    doRun();
   }
  }

  Module["run"] = run;

  function exit(status, implicit) {
   if (implicit && noExitRuntime && status === 0) {
    return;
   }
   if (noExitRuntime) ; else {
    exitRuntime();
    if (Module["onExit"]) Module["onExit"](status);
    ABORT = true;
   }
   quit_(status, new ExitStatus(status));
  }

  if (Module["preInit"]) {
   if (typeof Module["preInit"] == "function") Module["preInit"] = [ Module["preInit"] ];
   while (Module["preInit"].length > 0) {
    Module["preInit"].pop()();
   }
  }

  var shouldRunNow = true;

  if (Module["noInitialRun"]) shouldRunNow = false;

  run();


    return exorbitant.ready
  }
  );
  })();

  // Copyright (c) 2020 Milan Raj

  // Make sure to use Module.stackSave() before calling
  const writeStringToStack = function (Module, str) {
      var strMaxStackLength = (str.length << 2) + 1;
      var strStackPointer = Module.stackAlloc(strMaxStackLength);
      Module.stringToUTF8(str, strStackPointer, strMaxStackLength);
      return strStackPointer;
  };

  class Variable {
      constructor (Module, variableRef) {
          this._Module = Module;
          this._variableRef = variableRef;
      }

      set value (number) {
          this._Module.HEAPF64[this._variableRef / 8] = number;
      }

      get value () {
          return this._Module.HEAPF64[this._variableRef / 8];
      }
  }

  class Vector {
      constructor (Module, vectorRef, size) {
          this._Module = Module;
          this._vectorRef = vectorRef;
          this._size = size;
      }

      // Only valid until before another exorbitant function used. DO NO SAVE REFERENCE.
      // Memory growth due to function execution will invalidate buffer.
      createBufferView () {
          return new Float64Array(this._Module.HEAP8.buffer, this._vectorRef, this._size);
      }

      assign (arrayLike) {
          for (let i = this._vectorRef / 8; i < this._size; i++) {
              this._Module.HEAPF64[i] = arrayLike[i];
          }
      }
  }

  class SymbolTable {
      constructor (Module, symbolTableRef) {
          this._Module = Module;
          this._symbolTableRef = symbolTableRef;
      }

      createVariable (name) {
          const variableRef = this._Module._malloc(8);
          if (variableRef === 0) {
              throw new Error(`Not enough memory to allocate variable ${name}.`);
          }
          const stack = this._Module.stackSave();
          const nameRef = writeStringToStack(this._Module, name);
          const ret = this._Module._SymbolTable_AddVariable(this._symbolTableRef, nameRef, variableRef);
          this._Module.stackRestore(stack);
          this._Module.exorbitantFlush();
          return new Variable(this._Module, variableRef);
      }

      createVector (name, size) {
          const vectorRef = this._Module._malloc(size * 8);
          if (vectorRef === 0) {
              throw new Error(`Not enough memory to allocate vector ${name} with size ${size}.`);
          }
          const stack = this._Module.stackSave();
          const nameRef = writeStringToStack(this._Module, name);
          const ret = this._Module._SymbolTable_AddVector(this._symbolTableRef, nameRef, vectorRef, size);
          this._Module.stackRestore(stack);
          this._Module.exorbitantFlush();
          return new Vector(this._Module, vectorRef, size);
      }
  }

  class Expression {
      constructor (Module, expressionRef) {
          this._Module = Module;
          this._expressionRef = expressionRef;
      }

      registerSymbolTable (symbolTable) {
          this._Module._Expression_RegisterSymbolTable(this._expressionRef, symbolTable._symbolTableRef);
          this._Module.exorbitantFlush();
      }

      value () {
          const ret = this._Module._Expression_Value(this._expressionRef);
          this._Module.exorbitantFlush();
          return ret;
      }
  }

  class Parser {
      constructor (Module, parserRef) {
          this._Module = Module;
          this._parserRef = parserRef;
      }

      compile (str, expression) {
          const stack = this._Module.stackSave();
          const strRef = writeStringToStack(this._Module, str);
          const ret = this._Module._Parser_Compile(this._parserRef, strRef, expression._expressionRef);
          this._Module.stackRestore(stack);
          this._Module.exorbitantFlush();
          return ret;
      }
  }

  class Exorbitant {
      constructor (Module) {
          this._Module = Module;
      }

      createSymbolTable () {
          const symbolTableRef = this._Module._SymbolTable_Create();
          this._Module.exorbitantFlush();
          return new SymbolTable(this._Module, symbolTableRef);
      }

      createExpression () {
          const expressionRef = this._Module._Expression_Create();
          this._Module.exorbitantFlush();
          return new Expression(this._Module, expressionRef);
      }

      createParser () {
          const parserRef = this._Module._Parser_Create();
          this._Module.exorbitantFlush();
          return new Parser(this._Module, parserRef);
      }
  }

  const createExorbitant = async function () {
      const ModuleIn = {
          arguments: ['--exit']
      };
      const ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
      if (ENVIRONMENT_IS_NODE) {
          ModuleIn.locateFile = function (path, prefix) {
              if (path.endsWith('.wasm')) {
                  return __dirname + '/exorbitant.wasm';
              }
              return prefix + path;
          };
          ModuleIn.quit = function (status, toThrow) {
              throw toThrow;
          };
      }
      const Module = await exorbitant(ModuleIn);
      return new Exorbitant(Module);
  };

  exports.createExorbitant = createExorbitant;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
